package vultura.factor

import vultura.factor.generation.graph._

import scala.language.postfixOps
import scala.util.Random

package object generation {
  /** Generate lattice problems with fixed domain size for all variables, with parameters according to the Potts model.
    * @param dimensions The sizes of the dimensions of the grid. Set boolean indicator to true for wrapping dimension.
    */
  def pottsGrid(dimensions: Iterable[(Int,Boolean)],
                domainSize: Int = 2,
                pairwisePotts: Generator[Double]): Generator[LabeledProblem[IndexedSeq[Int]]] = Generator { r =>
    val graph = generateGrid(dimensions.toIndexedSeq, domainSize)
    val pairwiseFactors = graph.structure.scopeOfFactor.map(pottsFactor(graph.structure.domains,_,pairwisePotts, r))
    LabeledProblem(Problem(pairwiseFactors, graph.structure.domains, LogD), graph.variableLabels)
  }

  /** Generates a Potts factor in Log domain. */
  def pottsFactor(domains: Array[Int], scope: Array[Var], coupling: Generator[Double], random: Random): Factor =
    Factor.fromFunction(scope, domains, state => if (state.distinct.size == 1) coupling.generate(random) else 0d)


  /** Works only for binary valued problems.
    * For each variable, the energy generated by `energyOfOne` is added if the variable is 1. */
  def withMagneticField[A](p: LabeledProblem[A], energyOfOne: Generator[Double]): Generator[LabeledProblem[A]] = {
    require(p.problem.domains.forall(_ == 2))
    require(p.problem.ring == LogD)
    val singletons = p.problem.variables.map(v => energyOfOne.map(e => Factor(Array(v), Array(e, LogD.one))))
    Generator.seq(singletons).map( ss =>
      p.copy(problem = p.problem.copy(factors = p.problem.factors ++ ss))
    )
  }

  def generateGrid(dimensions: IndexedSeq[(Int,Boolean)], domainSize: Int = 2): LabeledProblemStructure[IndexedSeq[Int]] =
    StructureGenerator.fixedDomainSize[IndexedSeq[Int]](Constant(lattice(dimensions:_*)), domainSize).generate(null)
}
